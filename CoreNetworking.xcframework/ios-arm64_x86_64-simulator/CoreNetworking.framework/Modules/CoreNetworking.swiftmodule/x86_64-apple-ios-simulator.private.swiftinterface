// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target x86_64-apple-ios15.6-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name CoreNetworking
// swift-module-flags-ignorable: -enable-bare-slash-regex
@_exported import Apollo
@_exported import ApolloAPI
@_exported import CoreLogger
@_exported import CoreStorage
import CoreTelephony
import DeveloperToolsSupport
import Foundation
import OSLog
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension Apollo.ApolloClient {
  #if compiler(>=5.3) && $AsyncAwait
  public func fetch<Query>(query: Query, source: CoreNetworking.ApolloCacheSource = .remote) async throws -> Apollo.GraphQLResult<Query.Data> where Query : ApolloAPI.GraphQLQuery
  #endif
  public func watch<Query>(query: Query, source: CoreNetworking.ApolloCacheSource = .remote) -> _Concurrency.AsyncThrowingStream<Apollo.GraphQLResult<Query.Data>, any Swift.Error> where Query : ApolloAPI.GraphQLQuery
}
extension Apollo.ApolloClient {
  #if compiler(>=5.3) && $AsyncAwait
  public func fetch<Query>(query: Query, cachePolicy: Apollo.CachePolicy = .default, contextIdentifier: Foundation.UUID? = nil, queue: Dispatch.DispatchQueue = .main) async throws -> Apollo.GraphQLResult<Query.Data> where Query : ApolloAPI.GraphQLQuery
  #endif
  public func watch<Query>(query: Query, cachePolicy: Apollo.CachePolicy = .default, callbackQueue: Dispatch.DispatchQueue = .main) -> _Concurrency.AsyncThrowingStream<Apollo.GraphQLResult<Query.Data>, any Swift.Error> where Query : ApolloAPI.GraphQLQuery
  #if compiler(>=5.3) && $AsyncAwait
  public func perform<Mutation>(mutation: Mutation, publishResultToStore: Swift.Bool = true, queue: Dispatch.DispatchQueue = .main) async throws -> Apollo.GraphQLResult<Mutation.Data> where Mutation : ApolloAPI.GraphQLMutation
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func upload<Operation>(operation: Operation, files: [Apollo.GraphQLFile], queue: Dispatch.DispatchQueue = .main) async throws -> Apollo.GraphQLResult<Operation.Data> where Operation : ApolloAPI.GraphQLOperation
  #endif
}
public class ApolloNetworkManager {
  public var environment: CoreNetworking.APIEnvironment
  public var tokenManagement: any CoreNetworking.TokenManagement
  public var apollo: Apollo.ApolloClient {
    get
  }
  public init(environment: CoreNetworking.APIEnvironment, tokenManagement: any CoreNetworking.TokenManagement)
  @objc deinit
}
extension CoreNetworking.TokenPayload : Swift.Equatable {
}
public func == (lhs: CoreNetworking.TokenPayload, rhs: CoreNetworking.TokenPayload) -> Swift.Bool
extension CoreNetworking.TokenPayload.AppMetadata : Swift.Equatable {
}
public func == (lhs: CoreNetworking.TokenPayload.AppMetadata, rhs: CoreNetworking.TokenPayload.AppMetadata) -> Swift.Bool
extension CoreNetworking.NetworkError : Swift.Equatable {
}
public func == (lhs: CoreNetworking.NetworkError, rhs: CoreNetworking.NetworkError) -> Swift.Bool
public enum ApolloCacheSource {
  case remote
  case cache
  public static func == (a: CoreNetworking.ApolloCacheSource, b: CoreNetworking.ApolloCacheSource) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Encodable {
  public var bodyString: [Swift.String : Any] {
    get
  }
}
public enum Config {
  public enum Pagarme {
    public static let sandboxKey: Swift.String
    public static let prodKey: Swift.String
  }
}
public enum Technology {
  case nrnsa, nr, lte, ehrpd, hsdpa, wcdma, huspa, cdmaevdorev0, cdmaevdoreva, cdmaevdorevb, edge, gprs, cdma1x, unknown, other(Swift.String)
}
public struct RadioAccessTechnology {
  public init()
  public func getCurrentRadioAccessTechnology() -> CoreNetworking.Technology
}
public struct HTTPData<T> : Swift.Codable where T : Swift.Decodable, T : Swift.Encodable {
  public let data: T
  public init(data: T)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum APIEnvironment {
  case production
  case development
  public static func == (a: CoreNetworking.APIEnvironment, b: CoreNetworking.APIEnvironment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct InternetConnection {
  public static var reachability: CoreNetworking.Reachability!
  public enum Status {
    case unreachable, wifi, wwan(CoreNetworking.Technology)
  }
  public enum Error : Swift.Error {
    case failedToSetCallout
    case failedToSetDispatchQueue
    case failedToCreateWith(Swift.String)
    case failedToInitializeWith(Darwin.sockaddr_in)
  }
}
public enum Method : Swift.String {
  case post, get, patch, put, delete
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum NetworkError : Swift.Error {
  case cannotFetch(Swift.String)
  case notFound
  case RECENTLY_CREATED_CONFIG
}
public class NetworkManager : CoreNetworking.NetworkManagerInterface {
  public init(session: Foundation.URLSession = .shared, decodeStrategy: Foundation.JSONDecoder.KeyDecodingStrategy = .convertFromSnakeCase, encodeStrategy: Foundation.JSONEncoder.KeyEncodingStrategy = .convertToSnakeCase)
  #if compiler(>=5.3) && $AsyncAwait
  public func fetch<T>(type: T.Type, urlString: Swift.String, path: Swift.String, method: CoreNetworking.Method, headers: [Swift.String : Swift.String] = [:], body: (any Swift.Decodable & Swift.Encodable)? = nil) async throws -> T where T : Swift.Decodable, T : Swift.Encodable
  #endif
  @objc deinit
}
public protocol NetworkManagerInterface {
  #if compiler(>=5.3) && $AsyncAwait
  func fetch<T>(type: T.Type, urlString: Swift.String, path: Swift.String, method: CoreNetworking.Method, headers: [Swift.String : Swift.String], body: (any Swift.Decodable & Swift.Encodable)?) async throws -> T where T : Swift.Decodable, T : Swift.Encodable
  #endif
}
public protocol NetworkSpeedTesterDelegate : AnyObject {
  func speedDidChange(speed: CoreNetworking.NetworkSpeed)
}
public enum NetworkSpeed : Swift.String {
  case unreachable, slow, fast
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc final public class NetworkSpeedTester : ObjectiveC.NSObject {
  weak final public var delegate: (any CoreNetworking.NetworkSpeedTesterDelegate)?
  public init(url: Foundation.URL)
  public init(stringURL: Swift.String)
  @objc deinit
  final public func start()
}
extension CoreNetworking.NetworkSpeedTester : Foundation.URLSessionDownloadDelegate {
  @objc final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  @objc final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
}
@_hasMissingDesignatedInitializers public class NetworkStatus {
  public static let shared: CoreNetworking.NetworkStatus
  public var status: CoreNetworking.InternetConnection.Status?
  public func set(status: CoreNetworking.InternetConnection.Status)
  @objc deinit
}
extension Foundation.NSNotification.Name {
  public static let flagsChanged: Foundation.Notification.Name
}
public class Reachability {
  public var status: CoreNetworking.InternetConnection.Status {
    get
  }
  public init(hostname: Swift.String) throws
  public init() throws
  @objc deinit
}
public struct TokenPayload : Swift.Codable {
  public let userId: Swift.String
  public let email: Swift.String
  public let name: Swift.String?
  public let emailVerified: Swift.Bool
  public let appMetadata: CoreNetworking.TokenPayload.AppMetadata
  public static let none: CoreNetworking.TokenPayload
  public struct AppMetadata : Swift.Codable {
    public let lineIds: [Swift.String]
    public static let none: CoreNetworking.TokenPayload.AppMetadata
    public init(lineIds: [Swift.String])
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public init(userId: Swift.String, email: Swift.String, name: Swift.String?, emailVerified: Swift.Bool, appMetadata: CoreNetworking.TokenPayload.AppMetadata)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol TokenManagement {
  func forcingRefresh(completion: @escaping (Swift.Result<Swift.String, any Swift.Error>) -> Swift.Void)
}
extension CoreNetworking.ApolloCacheSource : Swift.Equatable {}
extension CoreNetworking.ApolloCacheSource : Swift.Hashable {}
extension CoreNetworking.APIEnvironment : Swift.Equatable {}
extension CoreNetworking.APIEnvironment : Swift.Hashable {}
extension CoreNetworking.Method : Swift.Equatable {}
extension CoreNetworking.Method : Swift.Hashable {}
extension CoreNetworking.Method : Swift.RawRepresentable {}
extension CoreNetworking.NetworkSpeed : Swift.Equatable {}
extension CoreNetworking.NetworkSpeed : Swift.Hashable {}
extension CoreNetworking.NetworkSpeed : Swift.RawRepresentable {}
